export MASTER_NODE_HOSTNAME=ta-bami-cluster-1
export MASTER_NODE_PUBLIC_IP=203.255.255.108
export MASTER_NODE_PRIVATE_IP=10.101.0.104

##Worker Node Count Info

export WORKER_NODE_CNT=3

##Add Worker Node Info

export WORKER1_NODE_HOSTNAME=ta-bami-cluster-2
export WORKER1_NODE_PRIVATE_IP=10.101.0.145
export WORKER2_NODE_HOSTNAME=ta-bami-cluster-3
export WORKER2_NODE_PRIVATE_IP=10.101.0.58
export WORKER3_NODE_HOSTNAME=ta-bami-cluster-4
export WORKER3_NODE_PRIVATE_IP=10.101.0.237

##Storage Type Info (eg. nfs, rook-ceph)

export STORAGE_TYPE=nfs
export NFS_SERVER_PRIVATE_IP=10.101.0.159





Jenkins를 이용한 container image push -> Container Registry 


# jenkins


git clone https://github.com/scriptcamp/kubernetes-jenkins

`kubectl create namespace devops-tools`

`kubectl apply -f serviceAccount.yaml`

`kubectl create -f volume.yaml`

`kubectl apply -f deployment.yaml`

- node 이름은 내 cluster node이름으로 바꿔주기

`kubectl apply -f service.yaml`

http://10.101.0.145:32000/login?from=%2F


`kubectl logs jenkins-deployment-2539456353-j00w5 --namespace=devops-tools`

- 비밀번호 

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

ddb079f4e843488fb86acc8922a5c78d

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword


`helm repo add jenkinsci https://charts.jenkins.io
helm repo update`

- 출력

`NAME             	CHART VERSION	APP VERSION	DESCRIPTION
jenkinsci/jenkins	4.3.22       	2.387.2    	Jenkins - Build great things at any scale! The ...`

`helm search repo jenkinsci`

- nfs 영구볼륨 만들기

  `mount -t nfs 10.101.0.159:/home/share/nfs /data/jenkins-volume`
  
  

# jenkins 설치

1. ### jenkins-values.yaml 생성

- 
  storageClass: jenkins-pv
  

  ```yaml
  serviceAccount:
    create: false
  # Service account name is autogenerated by default
  name: jenkins
  annotations: {}
  ```

2. helm install 
3. helm chart 

```
$ chart=jenkinsci/jenkins
$ helm install jenkins -n jenkins -f jenkins-values.yaml $chart
```

- 출력

```
NAME: jenkins
LAST DEPLOYED: Wed Sep 16 11:13:10 2020
NAMESPACE: jenkins
STATUS: deployed
REVISION: 1
```

3. admin 비밀번호 

```
$ jsonpath="{.data.jenkins-admin-password}"
$ secret=$(kubectl get secret -n jenkins jenkins -o jsonpath=$jsonpath)
$ echo $(echo $secret | base64 --decode)
```

- 출력 

  TlCHnBc2XbhAgPhAJh4yB8

4. jenkins URL 

   ```
   jsonpath="{.spec.ports[0].nodePort}" 
   NODE_PORT=$(kubectl get -n jenkins -o jsonpath=$jsonpath services jenkins)
   jsonpath="{.items[0].status.addresses[0].address}"
   NODE_IP=$(kubectl get nodes -n jenkins -o jsonpath=$jsonpath)
   echo http://$NODE_IP:$NODE_PORT/login
   ```

- 출력

  http://10.101.0.104:/login



# jenkins admin User info

jeongbami tmdgP0425ab!

bami

hyhyhye90@gmail.com

http://10.101.0.145:32000/



# jenkins github 연동

1. ssh-keygen 으로 생성
2. $ cat id_rsa.pub  / copy
3. github main > setting > ssh and gpg keys > new ssh key > copied > 등록
4. jenkins web에도 똑같이 key 등록 ( id_rsa private key로 등록)



------

------

------


# argoCD install

kubectl create namespace argocd 

kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml



# argocd CLI 

VERSION=$(curl --silent "https://api.github.com/repos/argoproj/argo-cd/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')

curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64

 - curl: (23) Failed writing body (0 != 1369)

   - 권한문제 ? sudo su 로 바꾸어 설치 -> 잘안됨

   - wget https://github.com/argoproj/argo-cd/releases/download/v2.2.3/argocd-linux-amd64 -O /usr/local/bin/argocd 

     :: 성공 

chmod +x /usr/local/bin/argocd

# argoCD login CLI

# git : 

# token: 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

kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2

- argocd-server-5b69986577-b9k48

argocd login argocd-server-5b69986577-b9k48

1. portfowarding 방식 사용하기

   1. *# NodePort 타입으로 접근* kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}' node IP:NodePort 로 접속 

   2. `service/argocd-server                             NodePort    10.233.31.254   <none>        80:32056/TCP,443:30941/TCP   85m   app.kubernetes.io/name=argocd-server`

      `pod/argocd-server-5b69986577-b9k48                      1/1     Running   0          85m   10.233.87.198   ta-bami-cluster-4`

   3. $ k get nodes -o wide

      `ta-bami-cluster-4   Ready    <none>          2d2h   v1.25.6   10.101.0.237   <none>        Ubuntu 20.04.5 LTS   5.4.0-139-generic   cri-o://1.25.1`

   4. http://{NODEIP}:{NODEPORT}

      == https://10.101.0.237:32056/

   5. 첫 로그인 id : admin

   6. 비밀번호

      1. kubectl get secrtes -n argocd

      2.  k get -n argocd secrets argocd-initial-admin-secret -o yaml

         ```yaml
         apiVersion: v1
         data:
           password: eUhjYWhacHNhYWY1RWtOZA==
         kind: Secret
         metadata:
           creationTimestamp: "2023-04-19T06:23:32Z"
           name: argocd-initial-admin-secret
           namespace: argocd
           resourceVersion: "352535"
           uid: df2c51c3-d524-41a0-ba75-da8ebf166837
         type: Opaque`
         ```

         ` echo eUhjYWhacHNhYWY1RWtOZA== | base64 -d`

         ##### `yHcahZpsaaf5EkNd`

      3. 
      `kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d`

         ##### `yHcahZpsaaf5EkNd`

      - 출력이 똑같은 것을 확인 할 수 있음.

# argoCD github 연동

### git : 

id : jeongbami

### pw:  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

1. ssh-keygen -t ed25519 -a 100 -f ${KEYNAME}
2. cat {KEYNAME}.pub
3. copy
4. github > repository > 수행중인 repository click (현재 msa repository)> setting >  deploy keys > Add deploy key> paste > 'add' check > deploy
5. argoCD Ui 이동
6. setting > connect REPO
7. 1. name : git repository 
      - 현재 기준 : 5개
   2. name project : default 
   3. repository URL : git repository 'ssh' URL 
   4. ssh key : private key copy and paste

- repository는 private여야 함..

argocd repo add ssh://git@github.com:jeongbami/msa.git --ssh-private-key-path ~/workspace/ssh-keys/argocd/argocd-github-key-rsa

argocd repo add git@github.com:jeongbami/service-repository.git --username myuser --password mypassword

argocd repo add git@github.com:jeongbami/service-repository.git --ssh-private-key-path ~/.ssh/argocd-github-key-rsa

argocd repo add git@github.com:jeongbami/service-repository.git --ssh-private-key-path ~/.ssh/argocd-github-key-rsa --insecure-ignore-host-key

argocd repo add ssh://git@github.com:1122/jeongbami/service-repository.git --ssh-private-key-path ~/.ssh/argocd-github-key-rsa --insecure-ignore-host-key

-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZWQyNTUxOQAAACDdk1H2/AMHyf4IZKkcnFXh1+FAaibO586Q6uypZXZdQAAAAKCCIcI2giHCNgAAAAtzc2gtZWQyNTUxOQAAACDdk1H2/AMHyf4IZKkcnFXh1+FAaibO586Q6uypZXZdQAAAAEB6BniLQmAtyvlGuSb1Crx42Zu8N9fG8H9eRbZDJ1b+Wd2TUfb8AwfJ/ghkqRycVeHX4UBqJs7nzpDq7Klldl1AAAAAGHVidW50dUB0YS1iYW1pLWNsdXN0ZXItMQECAwQF
-----END OPENSSH PRIVATE KEY-----



argocd login 10.101.0.237:32056 --port-forward-namespace argocd
argocd login 10.101.0.237:30007
## 	<issue>

1. argocd -- git  connect 

   - 10.101.0.237:32056 // 20.200.245.247:22 커넥이 안되는 상태 

argocd repo add ssh://git@20.200.245.247/jeongbami/msa.git --ssh-private-key-path ~/.ssh/argocd-github-key-rsa

   - ingress

     ```yaml
     apiVersion: networking.k8s.io/v1
     kind: Ingress
     metadata:
       name: argocd-ingress
       namespace: argocd
       annotations:
         nginx.ingress.kubernetes.io/rewrite-target: /
     spec:
       rules:
         - host: 10.101.0.237
           http:
             paths:
               - path: /argocd
                 pathType: Prefix
                 backend:
                   service:
                     name: argocd-server
                     port:
                       number: 80
               - path: /argocd-api
                 pathType: Prefix
                 backend:
                   service:
                     name: argocd-repo-server
                     port:
                       number: 8081 
     ```

     ```yaml
     apiVersion: extensions/v1beta1
     kind: Ingress
     metadata:
       name: argocd-server-http-ingress
       namespace: argocd
       annotations:
         kubernetes.io/ingress.class: "nginx"
         nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
         nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
     spec:
       rules:
       - http:
           paths:
           - backend:
               serviceName: argocd-server
               servicePort: http
         host: 10.101.0.237
       tls:
       - hosts:
         - 10.101.0.237
         secretName: argocd-secret # do not change, this is provided by Argo CD
     ```

     ```yaml
     
     apiVersion: networking.k8s.io/v1
     kind: Ingress
     metadata:
       name: argocd-server-http-ingress
       namespace: argocd
       annotations:
         kubernetes.io/ingress.class: "nginx"
         nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
         nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
     spec:
       rules:
       - host: argocd.example.com
         http:
           paths:
           - path: /
             pathType: Prefix
             backend:
               service:
                 name: argocd-server
                 port:
                   name: http
       tls:
       - hosts:
         - 10.101.0.237
         secretName: argocd-secret # do not change, this is provided by Argo CD
     ```

     - port number 80 : http / port 443 : https

     - etc/hosts domain 등록

       ``` 
       10.101.0.237  argocd.example.com
       
       ```

       ```yaml
       apiVersion: networking.k8s.io/v1
       kind: Ingress
       metadata:
         name: argocd-server-ingress
         namespace: argocd
         annotations:
           cert-manager.io/cluster-issuer: letsencrypt-prod
           kubernetes.io/ingress.class: nginx
           kubernetes.io/tls-acme: "true"
           nginx.ingress.kubernetes.io/ssl-passthrough: "true"
           nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
       spec:
         rules:
         - host: 지정할 주소 (ex. kubernetes.docker.com)
           http:
             paths:
             - path: /
               pathType: Prefix
               backend:
                 service:
                   name: argocd-server
                   port:
                     name: https
         tls:
         - hosts:
           - 지정할 주소
           secretName: argocd-secret
           
           
       ```

2. ingress 설치

   ```
   git clone https://github.com/kubernetes/ingress-nginx.git
   cd ./ingress-nginx/deploy/static/provider/baremetal
   # kubectl apply -f .
   kubectl apply -k ./
   kubectl get deploy -n ingress-nginx
   kubectl get svc -n ingress-nginx
   
   # 사설인증서를 사용할 경우 아래 명령 실행
   kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission
   ```

```bash
➜  argocd repo add git@github.com:jeongbami/cicd.git --ssh-private-key-path /home/ubuntu/workspace/argocd/keys/argocd-github-key
```

3. nodeport 따로 만든 후 app 배포 및 git연동방법 

   1. argco app 만들기 

      ```yaml
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: argocd-app
        namespace: argocd
      spec:
        destination:
          namespace: default
          server: https://kubernetes.default.svc
        project: default
        source:
          helm:
            valueFiles:
              - values.yaml
          path: manifests/helm-app
          repoURL: https://github.com/jeongbami/cicd.git
          targetRevision: HEAD
        syncPolicy: {}
      ```

      

   2. nodePort용 svc

   ```
   kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "ClusterIP"}}'
   ```

   ```yaml
   apiVersion: v1
   kind: Service
   metadata:
     labels:
       app.kubernetes.io/component: server
       app.kubernetes.io/name: argocd-server
       app.kubernetes.io/part-of: argocd
     name: argocd-server-nodeport
     namespace: argocd
   spec:
     ports:
       - name: http
         port: 80
         protocol: TCP
         targetPort: 8080
         nodePort: 30007
       - name: https
         port: 443
         protocol: TCP
         targetPort: 8080
         nodePort: 30008
     selector:
       app.kubernetes.io/name: argocd-server
     sessionAffinity: None
     type: NodePort
   ```

   2) git 연동 secret key

   ```
   ubuntu@ta-bami-cluster-1:~/workspace/argocd/keys$ cat argocd-github-key | base64
   LS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0KYjNCbGJuTnphQzFyWlhrdGRqRUFB
   QUFBQkc1dmJtVUFBQUFFYm05dVpRQUFBQUFBQUFBQkFBQUFNd0FBQUF0emMyZ3RaVwpReU5UVXhP
   UUFBQUNEaExXbVBXNmlTc1I1azBJVlI4aEZiUUplOUFOSHhtcE16SnhXdjZUWXVwd0FBQUtCMUZj
   SDhkUlhCCi9BQUFBQXR6YzJndFpXUXlOVFV4T1FBQUFDRGhMV21QVzZpU3NSNWswSVZSOGhGYlFK
   ZTlBTkh4bXBNekp4V3Y2VFl1cHcKQUFBRUFnaUtGZ2VYK2tIbXJ3c0xtVzkxVUE3YW9BR093Q0NO
   TmNmUGNpZ1E1dURPRXRhWTlicUpLeEhtVFFoVkh5RVZ0QQpsNzBBMGZHYWt6TW5GYS9wTmk2bkFB
   QUFHSFZpZFc1MGRVQjBZUzFpWVcxcExXTnNkWE4wWlhJdE1RRUNBd1FGCi0tLS0tRU5EIE9QRU5T
   U0ggUFJJVkFURSBLRVktLS0tLQo=
   ```

   3) configmap으로 전달 


# git app



argocd app create msa-app  --repo git@github.com:jeongbami/msa.git --ssh-private-key-path /home/ubuntu/workspace/ssh-keys/argocd/argocd-github-key-rsa --path path/to/manifests --dest-namespace my-namespace --dest-server https://my-kubernetes-cluster.example.com --sync-policy automated


# edu sections manifest 배포 
- namespace = edu 공통
- apply는 app version의 이력을 남기기때문에 manifest 배포시 apply  이용
- jdk8 / tomcat 9.0.73 
  docker pull tomcat:9.0.73-jdk8-temurin-focal

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edu-msa-ui
  namespace: edu
spec:
  replicas: 2
  selector:
    matchLabels:
      app: edu-msa-ui
  template:
    metadata:
      labels:
        app: edu-msa-ui
    spec:
      containers:
      - name: edu-msa-ui
        image: tomcat:9.0.73-jdk8-temurin-focal
        ports:
        - containerPort: 8080
        env:
        - name: JAVA_OPTS
          value: "-Djava.security.egd=file:///dev/urandom"
```
```yaml
apiVersion: v1
kind: Service
metadata:
  name: edu-msa-ui
  namespace: edu
spec:
  selector:
    app: edu-msa-ui
  ports:
  - name: http
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

# ssh-key 등록

1. key 생성
2. key 등록 
```
eval $(ssh-agent)
ssh-add argocd-github-key-rsa
  출력 Identity added: argocd-github-key-rsa (ubuntu@ta-bami-cluster-1)
```
3. git 등록
setting > SSH key 등록 > public key 등록

```console
---
ssh: connect to host github.com port 22: Connection timed out
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
---
vim ~/.ssh/config

+)
Host github.com
  Hostname ssh.github.com
  Port 443

ssh -T git@github.com

The authenticity of host '[ssh.github.com]:443 ([20.200.245.248]:443)' can't be established.
ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[ssh.github.com]:443,[20.200.245.248]:443' (ECDSA) to the list of known hosts.
Hi jeongbami! You've successfully authenticated, but GitHub does not provide shell access.

git clone git@github.com:jeongbami/gitops-repository.git

Cloning into 'gitops-repository'...
remote: Enumerating objects: 402, done.
remote: Total 402 (delta 0), reused 0 (delta 0), pack-reused 402
Receiving objects: 100% (402/402), 93.89 MiB | 9.52 MiB/s, done.
Resolving deltas: 100% (68/68), done.
```

```
ssh -vT git@github.com    로그확인
```

kubectl config set-context --current --namespace=argocd

argocd login --insecure 10.101.0.58:32443

yHcahZpsaaf5EkNd

kubectl config set-cluster cluster.local --server=https://10.101.0.104:6443
kubectl config use-context my-context


kubectl config set-cluster cluster.local --server=https://10.233.0.1:443
```
$ k config view
$ ubuntu@ta-bami-cluster-1:~$ k config view
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://127.0.0.1:6443
  name: cluster.local
contexts:
- context:
    cluster: cluster.local
    namespace: argocd
    user: kubernetes-admin
  name: kubernetes-admin@cluster.local
current-context: kubernetes-admin@cluster.local
kind: Config
preferences: {}
users:
- name: kubernetes-admin
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED

A:  the server URL for the cluster.local

$ k describe kube-apiserver-ta-...
$ Name:                 kube-apiserver-ta-bami-cluster-1
Namespace:            kube-system
Priority:             2000001000
Priority Class Name:  system-node-critical
Node:                 ta-bami-cluster-1/10.101.0.104
Start Time:           Mon, 17 Apr 2023 05:37:01 +0000
Labels:               component=kube-apiserver
                      tier=control-plane
Annotations:          kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 10.101.0.104:6443
                      kubernetes.io/config.hash: 0d70436ee085f728304bba21acc78180
                      kubernetes.io/config.mirror: 0d70436ee085f728304bba21acc78180
                      kubernetes.io/config.seen: 2023-04-17T05:36:54.009611491Z
                      kubernetes.io/config.source: file
Status:               Running
IP:                   10.101.0.104
IPs:
  IP:           10.101.0.104



$ kubectl config set-cluster cluster.local --server=https://10.101.0.104:6443


Q: why current server is 127.0.0.1:6443 in kubectl config nownow?
A: The reason why the current server in your kubectl configuration is set to 127.0.0.1:6443 is that this is the default address that kubectl uses to connect to the Kubernetes API server when you run commands on the same machine where the Kubernetes API server is running.

When you run kubectl commands on a different machine, you need to set the server field in your kubectl configuration to the IP address or hostname of the machine where the Kubernetes API server is running, as I described earlier.

If you are currently running kubectl on the same machine where the Kubernetes API server is running, then you can leave the server field as 127.0.0.1:6443. However, if you plan to run kubectl on a different machine, you will need to update this field accordingly.
```
kubectl config set-credentials my-credentials --username=<username> --password=<password>
kubectl config set-context my-context --cluster=my-k8s-cluster --user=my-credentials
kubectl config use-context my-context


# argocd위한 application.yaml

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: java-web-app
spec:
  destination:
    server: <ARGOCD_SERVER> 10.101.0.58:32443 
    namespace: <TARGET_NAMESPACE> edu
  source:
    repoURL: <GIT_REPO_URL>  git@github.com:jeongbami/gitops-repository.git 
    path: <PATH_TO_APP> src/main/java
    targetRevision: <GIT_BRANCH_OR_TAG> HEAD
  project: edu
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
  syncWave: 1
  healthChecks:
    - name: liveness
      command:
        - "curl"
        - "-f"
        - "http://localhost:8080/health"
  plugin:
    name: helm
    env:
      - name: JAVA_OPTS
        value: "-Djava.security.egd=file:///dev/urandom"
  values:
    - name: image.tag
      value: "latest"
    - name: service.port
      value: "8080"
    - name: service.type
      value: "ClusterIP"
    - name: tomcat.image
      value: "tomcat:9.0.73-jdk8-temurin-focal"
    - name: tomcat.contextPath
      value: "/"
    - name: tomcat.javaOpts
      value: "-Xmx512m -Djava.security.egd=file:/dev/./urandom"
    - name: tomcat.warFile
      value: "edu-msa-ui-1.0.0.war"
```

# service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-java-app-service
  namespace: my-namespace
spec:
  selector:
    app: my-java-app
  type: LoadBalancer
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
```      



git config --global url."https://github.com/".insteadOf git@github.com
git config --global url."https://".insteadOf git://

<tomcat-7>
 <Valve className="org.apache.catalina.valves.AccessLogValve"
allow="127\. \d+\. \d+\. \d+|::1|0:0:0:0:0:0:0:1||{jenkins server IP}"/>

<tomcat-9>
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
       prefix="localhost_access_log" suffix=".txt"
       pattern="%h %l %u %t &quot;%r&quot; %s %b" 
       condition="remoteHost.matches('127\\..*') || remoteHost.matches('0:0:0:0:0:0:0:1') || remoteHost.matches('10.101.0.145')"/>
